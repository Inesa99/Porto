@using Microsoft.AspNetCore.Identity
@using Porto.Data.Models
@inject UserManager<ApplicationUser> UserManager
@{
    ViewBag.Title = "Campanha Chatbot";
}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
<link href="~/css/main.css" rel="stylesheet" />
<link href="~/css/live.css" rel="stylesheet" />
<link href="~/css/chatbot.css" rel="stylesheet" />

<section class="hero-section live-hero" style="background-image:none !important;">
    <div class="hero-overlay live-overlay"></div>
    <div class="container position-relative">
        <partial name="_menuPartial" />

        <h2 style="margin-bottom:auto; text-align:center">
            AI Career Chat – Get Job Advice Anytime
        </h2>
        <p style="font-size:14px; text-align:center; margin:20px auto;">
            Not sure where to start?<br>
            Our AI Assistant can guide you on:
        </p>

        <!-- New Streamed Chat Form -->
        <form id="chatForm" class="new">
            <label>Select a Theme:</label>
            <select name="theme" id="theme">
                <option value="Living">How to find and apply for jobs</option>
                <option value="Work">Writing a simple CV & job application</option>
                <option value="Integration">What to expect in interviews / training</option>
                <option value="General">Workplace basics and general guidance</option>
            </select>

            <label>Ask a Question:</label><br />
            <input type="text" name="userMessage" id="userMessage" required style="width: 84%;" />
            <button type="submit">
                Ask
            </button>
        </form>

        <hr />

        <div id="chatBox">
            <!-- Responses will stream here -->
        </div>

        @* Fallback if user came from non-streaming POST *@
        @if (ViewBag.Response != null)
        {
            <p class="user"> @ViewBag.UserMessage</p>
            <div class="bot">
                @Html.Raw(ViewBag.Response)
            </div>
        }
    </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
    marked.setOptions({
      breaks: false,
      gfm: true
    });

    const chatForm = document.getElementById("chatForm");
    const userInput = document.getElementById("userMessage");
    const themeInput = document.getElementById("theme");
    const chatBox = document.getElementById("chatBox");
      function preprocessResponse(text) {
        return text
            .replace(/(\d+[\.\)])\s+/g, "\n$1 ")
            .replace(/([A-Za-z0-9])(:\s*\*)/g, "$1:\n*")
            .replace(/\n{2,}/g, "\n\n")
            .trim();
    }


    chatForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const question = userInput.value.trim();
      const theme = themeInput.value;

      if (!question) return;

      chatBox.innerHTML = "";

      const userDiv = document.createElement("div");
      userDiv.classList.add("chat-message", "user");
      userDiv.innerHTML = ` ${question}`;
      chatBox.appendChild(userDiv);

      const botDiv = document.createElement("div");
      botDiv.classList.add("chat-message", "bot");
      botDiv.innerHTML = " <div id='botContent'></div>";
      chatBox.appendChild(botDiv);

      const botContent = document.getElementById("botContent");

      try {
        const response = await fetch("/Bot/StreamResponse", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({ userMessage: question, theme: theme })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");

        let fullResponse = "";
        let lastUpdateTime = Date.now();

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          fullResponse += chunk;

          const now = Date.now();
          if (now - lastUpdateTime > 100) {
    const htmlContent = marked.parse(preprocessResponse(fullResponse));
                botContent.innerHTML = htmlContent;
            chatBox.scrollTop = chatBox.scrollHeight;
            lastUpdateTime = now;
          }
        }

        await renderTypingEffect(botContent, fullResponse, 5);

        botContent.querySelectorAll("p, li").forEach(el => {
          if (!el.textContent.trim()) el.remove();
        });

      } catch (error) {
        botContent.innerHTML = "<p style='color: #ff6b6b;'>Error: Could not get response. Please try again.</p>";
        console.error("[v0] Chat error:", error);
      }

      userInput.value = "";
      chatBox.scrollTop = chatBox.scrollHeight;
    });

      async function renderTypingEffect(container, text, speed = 10) {
      let index = 0;
      while (index < text.length) {
        const chunk = text.slice(0, index + 5);
        container.innerHTML = marked.parse(preprocessResponse(chunk));
        index += 5;
        await new Promise(r => setTimeout(r, speed));
      }
    }

</script>

